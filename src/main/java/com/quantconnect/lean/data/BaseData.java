/*
 * QUANTCONNECT.COM - Democratizing Finance, Empowering Individuals.
 * Lean Algorithmic Trading Engine v2.0. Copyright 2014 QuantConnect Corporation.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); 
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
*/

//using QuantConnect.Util;

package com.quantconnect.lean.data;

import java.math.BigDecimal;
import java.net.InetAddress;
import java.net.URI;
import java.time.LocalDateTime;

import com.quantconnect.lean.Global.MarketDataType;
import com.quantconnect.lean.Global.SubscriptionTransportMedium;
import com.quantconnect.lean.Symbol;

/// Abstract base data class of QuantConnect. It is intended to be extended to define 
/// generic user customizable data types while at the same time implementing the basics of data where possible
public abstract class BaseData implements IBaseData {
    
    private MarketDataType dataType = MarketDataType.Base;
    private LocalDateTime time;
    private Symbol symbol = Symbol.EMPTY;
    private BigDecimal value;
    private boolean isFillForward;

    /// Market Data Type of this data - does it come in individual price packets or is it grouped into OHLC.
    /// <remarks>Data is classed into two categories - streams of instantaneous prices and groups of OHLC data.</remarks>
    public MarketDataType getDataType() {
        return dataType;
    }
    
    public void setDataType( MarketDataType value ) {
        dataType = value;
    }

    /// True if this is a fill forward piece of data
    public boolean isFillForward() {
        return isFillForward;
    }

    /// Current time marker of this data packet.
    /// <remarks>All data is timeseries based.</remarks>
    public LocalDateTime getTime() {
        return time;
    }
    
    public void setTime( LocalDateTime value ) {
        time = value;
    }

    /// The end time of this data. Some data covers spans (trade bars) and as such we want
    /// to know the entire time span covered
    public LocalDateTime getEndTime() {
        return time;
    }
    
    public void setEndTime( LocalDateTime value ) {
        time = value;
    }
    
    /// Symbol representation for underlying Security
    public Symbol getSymbol() {
        return symbol;
    }
    
    public void setSymbol( Symbol value ) {
        symbol = value;
    }

    /// Value representation of this data packet. All data requires a representative value for this moment in time.
    /// For streams of data this is the price now, for OHLC packets this is the closing price.
    public BigDecimal getValue() {
        return value;
    }
    
    public void setValue( BigDecimal value ) {
        this.value = value;
    }

    /// As this is a backtesting platform we'll provide an alias of value as price.
    public BigDecimal getPrice() {
        return value;
    }

    /// Constructor for initialising the dase data class
    public BaseData() { 
        //Empty constructor required for fast-reflection initialization
    }

//    /// Reader converts each line of the data source into BaseData objects. Each data type creates its own factory method, and returns a new instance of the object 
//    /// each time it is called. The returned object is assumed to be time stamped in the config.ExchangeTimeZone.
//    /// <param name="config">Subscription data config setup object</param>
//    /// <param name="line">Line of the source document</param>
//    /// <param name="date">Date of the requested data</param>
//    /// <param name="isLiveMode">true if we're in live mode, false for backtesting mode</param>
//    /// <returns>Instance of the T:BaseData object generated by this line of the CSV</returns>
//    public BaseData reader( SubscriptionDataConfig config, String line, LocalDateTime date, boolean isLiveMode ) {
//        // stub implementation to prevent compile errors in user algorithms
//        final DataFeedEndpoint dataFeed = isLiveMode ? DataFeedEndpoint.LiveTrading : DataFeedEndpoint.Backtesting;
//        return reader( config, line, date, dataFeed );
//    }

    /// Return the URL String source of the file. This will be converted to a stream 
    /// <param name="config">Configuration object</param>
    /// <param name="date">Date of this source file</param>
    /// <param name="isLiveMode">true if we're in live mode, false for backtesting mode</param>
    /// <returns>String URL of source file.</returns>
    protected SubscriptionDataSource createSubscriptionDataSource( String source, boolean isLiveMode ) {
        if( isLiveMode )
            // live trading by default always gets a rest endpoint
            return new SubscriptionDataSource( source, SubscriptionTransportMedium.Rest );
        
        // construct a uri to determine if we have a local or remote file
        try {
            final URI uri = new URI( source ); //, UriKind.RelativeOrAbsolute);
            if( uri.isAbsolute() && !InetAddress.getByName( uri.getHost() ).isLoopbackAddress() )
                return new SubscriptionDataSource( source, SubscriptionTransportMedium.RemoteFile );
        }
        catch( Exception e ) { }
            
        return new SubscriptionDataSource( source, SubscriptionTransportMedium.LocalFile );
    }

    /// Updates this base data with a new trade
    /// <param name="lastTrade">The price of the last trade</param>
    /// <param name="tradeSize">The quantity traded</param>
    public void updateTrade( BigDecimal lastTrade, long tradeSize ) {
        update( lastTrade, BigDecimal.ZERO, BigDecimal.ZERO, BigDecimal.valueOf( tradeSize ), BigDecimal.ZERO, BigDecimal.ZERO );
    }

    /// Updates this base data with new quote information
    /// <param name="bidPrice">The current bid price</param>
    /// <param name="bidSize">The current bid size</param>
    /// <param name="askPrice">The current ask price</param>
    /// <param name="askSize">The current ask size</param>
    public void updateQuote( BigDecimal bidPrice, long bidSize, BigDecimal askPrice, long askSize ) {
        update( BigDecimal.ZERO, bidPrice, askPrice, BigDecimal.ZERO, BigDecimal.valueOf( bidSize ), BigDecimal.valueOf( askSize ) );
    }

    /// Updates this base data with the new quote bid information
    /// <param name="bidPrice">The current bid price</param>
    /// <param name="bidSize">The current bid size</param>
    public void updateBid( BigDecimal bidPrice, long bidSize ) {
        update( BigDecimal.ZERO, bidPrice, BigDecimal.ZERO, BigDecimal.ZERO, BigDecimal.valueOf( bidSize ), BigDecimal.ZERO );
    }

    /// Updates this base data with the new quote ask information
    /// <param name="askPrice">The current ask price</param>
    /// <param name="askSize">The current ask size</param>
    public void updateAsk( BigDecimal askPrice, long askSize ) {
        update( BigDecimal.ZERO, BigDecimal.ZERO, askPrice, BigDecimal.ZERO, BigDecimal.ZERO, BigDecimal.valueOf( askSize ) );
    }

    /// Update routine to build a bar/tick from a data update. 
    /// <param name="lastTrade">The last trade price</param>
    /// <param name="bidPrice">Current bid price</param>
    /// <param name="askPrice">Current asking price</param>
    /// <param name="volume">Volume of this trade</param>
    /// <param name="bidSize">The size of the current bid, if available</param>
    /// <param name="askSize">The size of the current ask, if available</param>
    public void update( BigDecimal lastTrade, BigDecimal bidPrice, BigDecimal askPrice, BigDecimal volume, BigDecimal bidSize, BigDecimal askSize ) {
        value = lastTrade;
    }

    /// Return a new instance clone of this object, used in fill forward
    /// <remarks>
    /// This base implementation uses reflection to copy all public fields and properties
    /// </remarks>
    /// <param name="fillForward">True if this is a fill forward clone</param>
    /// <returns>A clone of the current object</returns>
    public BaseData clone( boolean fillForward ) {
        final BaseData clone = clone();
        clone.isFillForward = fillForward;
        return clone;
    }

    /// Return a new instance clone of this object, used in fill forward
    /// <remarks>
    /// This base implementation uses reflection to copy all public fields and properties
    /// </remarks>
    /// <returns>A clone of the current object</returns>
    public BaseData clone() {
        try {
            return (BaseData) super.clone();
        }
        catch( CloneNotSupportedException e ) { 
            throw new RuntimeException( e );
        }
    }

    /// Formats a String with the symbol and value.
    /// <returns>string - a String formatted as SPY: 167.753</returns>
    public String toString() {
        return String.format( "%s: %s", symbol, value.toString() );
    }
}
