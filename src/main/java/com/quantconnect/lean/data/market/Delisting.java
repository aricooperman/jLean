/*
 * QUANTCONNECT.COM - Democratizing Finance, Empowering Individuals.
 * Lean Algorithmic Trading Engine v2.0. Copyright 2014 QuantConnect Corporation.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); 
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
*/

package com.quantconnect.lean.data.market;

import java.math.BigDecimal;
import java.time.LocalDate;

import com.quantconnect.lean.DelistingType;
import com.quantconnect.lean.MarketDataType;
import com.quantconnect.lean.Symbol;
import com.quantconnect.lean.data.BaseData;
import com.quantconnect.lean.data.SubscriptionDataConfig;
import com.quantconnect.lean.data.SubscriptionDataSource;
import com.quantconnect.lean.orders.OrderTicket;



/**
 * Delisting event of a security
 */
public class Delisting extends BaseData {
       
    private DelistingType type;
    private OrderTicket ticket;

    
    /**
     * Gets the type of delisting, warning or delisted
     * A <see cref="DelistingType.Warning"/> is sent
     */
    public DelistingType getType() {
        return type;
    }

    /**
     * Gets the <see cref="OrderTicket"/> that was submitted to liquidate this position
     */
    public OrderTicket getTicket() {
        return ticket;
    }

    /**
     * Initializes a new instance of the <see cref="Delisting"/> class
     */
    public Delisting() {
        setDataType( MarketDataType.Auxiliary );
        this.type = DelistingType.Delisted;
    }

    /**
     * Initializes a new instance of the <see cref="Delisting"/> class
     * @param symbol The delisted symbol
     * @param date The date the symbol was delisted
     * @param price The final price before delisting
     * @param type The type of delisting event
     */
    public Delisting( Symbol symbol, LocalDate date, BigDecimal price, DelistingType type ){
        this();
        setSymbol( symbol );
        setTime( date.atStartOfDay() );
        setValue( price );
        this.type = type;
    }

    /**
     * Sets the <see cref="OrderTicket"/> used to liquidate this position
     * @param ticket The ticket that represents the order to liquidate this position
     */
    public void setOrderTicket( OrderTicket ticket ) {
        this.ticket = ticket;
    }

    /**
     * Reader converts each line of the data source into BaseData objects. Each data type creates its own factory method, and returns a new instance of the object 
     * each time it is called. 
     * @param config Subscription data config setup object
     * @param line Line of the source document
     * @param date Date of the requested data
     * @param isLiveMode true if we're in live mode, false for backtesting mode
     * @returns Instance of the T:BaseData object generated by this line of the CSV
     */
    @Override
    public BaseData reader( SubscriptionDataConfig config, String line, LocalDate date, boolean isLiveMode ) {
        throw new UnsupportedOperationException( "This method is not supposed to be called on the Delisting type.");
    }

    /**
     * Return the URL String source of the file. This will be converted to a stream 
     * @param config Configuration object
     * @param date Date of this source file
     * @param isLiveMode true if we're in live mode, false for backtesting mode
     * @returns String URL of source file.
     */
    @Override
    public SubscriptionDataSource getSource( SubscriptionDataConfig config, LocalDate date, boolean isLiveMode ) {
        throw new UnsupportedOperationException( "This method is not supposed to be called on the Delisting type.");
    }

    /**
     * Return a new instance clone of this object, used in fill forward
     * 
     * This base implementation uses reflection to copy all public fields and properties
     * 
     * @returns A clone of the current object
     */
    @Override
    public BaseData clone() {
        return new Delisting( getSymbol(), getTime().toLocalDate(), getPrice(), type );
    }
}
